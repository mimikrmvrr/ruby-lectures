= slide 'Днес' do
  ul
    li Хешове
    li Методи
    li Обекти
    li Класове

= slide 'Бира в сряда' do
  list:
    Сряда ще пием бира вместо лекция
    Началото е (ориентировъчно) 19:30
    Мястото е ["Мазе" (бившия „Бар на края на вселената“) на Графа до Алабин и Христо Белчев](https://www.facebook.com/mazesofia)
    Присъствието ви не е задължително, но ще се радваме да се видим
    Има [събитие във Фейсбук](https://www.facebook.com/events/537931419620371/) - отбележете, ако ще идвате

= slide 'Първо предизвикателство' do
  list:
    Публикувано е [първото предизвикателство](/challenges/1)
    Имате време до сряда на [обяд](http://vbox7.com/play:f984595b)
    Малко, но забавно
    За въпроси, вижте [съответната тема във форумите](/topics)

= slide 'Pull Requests', 'revisited' do
  list:
    Миналия път говорихме малко за open-source и pull request-и
    Искаме да ви направим малка демонстрация

= slide 'Array - "списък" или "масив"', 'спорът със Стефан от миналия път' do
  list:
    Получихме малко обратна връзка за този спор
    Къде е истината?
    Често може да се появи в един хубав спор (дебат)
    Различните гледни точки са важни
    Не приемайте нищо наготово - мислете, бъдете критични, имайте мнение
    Критичното мислене от ваша страна е страшно важно

= slide 'Обратна връзка за лекциите', 'по темата с обратната връзка...' do
  p Вашата навременна обратна връзка е много важна за нас. Имате поне няколко начина да ни споделите какво мислите:

  ol
    li.action Пуснете тема във форума на курса
    li.action Имейл до <a href="mailto:fmi@ruby.bg">fmi@ruby.bg</a>
    li.action Псевдо-анонимно – "един приятел ми сподели..."
    li.action Говорете с нас по време на междучасието, след лекциите, на по бира...

= slide 'Малко за задачата', 'общи впечатления от предадените решения' do
  list:
    Вече има 30-ина предадени решения, на повечето съм оставил бележки
    Който е предал решение рано, има привилегията да получи нашето мнение и да си го коригира
    Имахте шанс да пробвате да ровите сами в една слабо позната технология
    Днес ще ви покажем още неща, които ще ви помогнат
    Преди това, малко бележки

= slide 'Конвенции' do
  list:
    Задължително прочетете [ръководството по стил](https://github.com/fmi/ruby-style-guide#readme)
    При нас тези неща имат силата на закон
    Казахме го вече, но все пак има решения, които са подредени като крем-супа
    Пак напомняме, ще взимаме точки при системното им неспазване
    Настройте си редактора - да показва trailing whitespace, интервали и табулации; да идентира правилно
    Запазвам си правото да не коментирам на решения, които са просто изсипана купчина символи

= slide 'Именоване' do
  list:
    Именоване – полагайте големи усилия, когато го правите; нека ви стане навик
    `tmp` е епитома на лошите имена
    Лоши са и `data`, `result`, `array`, `hash` – прекалено общи
    Лоши са `size1`, `size2` – със сигурност има някаква друга разлика между тях
    Лоши са `a`, `b`, `c`, `f`, `x`, `y`, `s` и всички други букви
    Има малко изключения на горното (например `i`, когато се използва като индексна променлива)
    В много ситуации може да избегнете създаването на променлива съвсем

= slide 'Именоване', 'не съкращавайте' do
  list:
    С неща от типа на `curr`, `prev`, `el`, `elem`, `num` не печелите нищо, но губите много
    Стремете се да спазвате [Clarity over brevity](http://37signals.com/svn/posts/3250-clarity-over-brevity-in-variable-and-method-names)

  blockquote.action
    ' If you work hard at being clear in your naming, you’ll also rarely need to write comments for the code.
      Comments are generally only needed when you failed to be clear enough in naming. Treat them as a code smell.
    p — DHH

= slide 'Именоване', 'Clarity over brevity' do
  example:
    def make_person_an_outside_subscriber_if_all_accesses_revoked
      person.update_attribute(:outside_subscriber, true) if person.reload.accesses.blank?
    end

    def shift_records_upward_starting_at(position)
      positioned_records.update_all "position = position - 1",
        ["position >= ?", position]
    end

    def someone_else_just_finished_writing?(document)
      if event = document.current_version_event
        !event.by_current_creator? and event.updated_at > 1.minute.ago
      end
    end

= slide 'Именоване', 'лоши примери' do
  .action
    p Какво прави следният код?
    example:
      tmp= if (self<0) then (tmp=(-1)*(self)) else (self) end

  .action
    p Ами този?
    example:
      absolute_value = self > 0 ? self : -self

= slide 'Именоване', 'лоши примери' do
  p В контекста на метод, проверяващ дали число е просто:

  .action
    example:
      middle = Math.sqrt(self)

  .action
    p vs.
    example:
      upper_limit = Math.sqrt(self)

= slide 'Именоване', 'и преводи' do
  list:
    `divider` означава "разделител, преграда, ..."
    `divisor` е делител
    Точният превод е важен
    Ползвайте речник, когато не сте сигурни

= slide 'Да обобщим', 'тайната на добрия код' do
  list:
    Спазване на конвенциите
    Стремеж към подходящи имена
    Прост и ясен дизайн

= slide 'Правила на Кент Бек за прост и ясен дизайн' do
  blockquote
    p My guiding light is Kent Beck's rules of Simple Design (<a href="http://ghendry.net/refactor.html">източник</a>):
    ol
      li.action The code must first be correct (as defined by tests);
      li.action then it should be a clear statement of the design (what J.B.Rainsberger calls "no bad names");
      li.action then it should contain no duplication (of text, of ideas, or of responsibility);
      li.action and finally it must be the smallest code that meets all of the above.
    p.action It's time to stop refactoring when the code makes a reasonable stab at meeting those goals, and when any further changes would add no further benefit.

= slide 'Вече съществуващи методи', 'и вечното преоткриване на колелото...' do
  list:
    В Ruby (core и stdlib) има много класове и модули
    В тях има много готова функционалност
    Преоткриването на колелото има и педагогически елемент, но...
    Когато пишете задачи, ви насърчаваме да търсите и ползвате тази функционалност

= slide 'Съществуващи методи (2)' do
  p Започнете да се запознавате с документацията на следните методи:
  list:
    [Enumerable](http://ruby-doc.org/core-2.1.0/Enumerable.html)
    [Array](http://ruby-doc.org/core-2.1.0/Array.html)
    [Hash](http://ruby-doc.org/core-2.1.0/Hash.html)
    [String](http://ruby-doc.org/core-2.1.0/String.html)
    [Numeric](http://ruby-doc.org/core-2.1.0/Numeric.html)
    [Integer](http://ruby-doc.org/core-2.1.0/Integer.html)
    [Fixnum](http://ruby-doc.org/core-2.1.0/Fixnum.html)
    [Float](http://ruby-doc.org/core-2.1.0/Float.html)
    [Rational](http://ruby-doc.org/core-2.1.0/Rational.html)

= slide 'Въпрос 1' do
  p Какво прави <code>&lt;=&gt;</code> (наричан <em>the space shuttle operator</em>)?

  .action.answer
    p
      ' Връща положително число (1), ако първия елемент е по-голям,
        нула, ако са равни и
        отрицателно (-1), ако първия е по-малък.
    p Помнете го като "минус".

= slide 'Въпрос 2' do
  p Какво извежда следният код и защо?

  example:
    puts 'foo' == 'foo', 'foo'.equal? 'foo'
    puts [] == [],       [].equal? []
    puts 42 == 42,       42.equal? 42
    puts :foo == :foo,   :foo.equal? :foo

  .action.answer
    p <code>==</code> сравнява по стойност, а <code>equal?</code> по идентитет.
    p Числата и символите се интернират.

= slide 'Итерация на масиви', 'преговор от предната сбирка' do
  p Итерира се с <code>#each</code>, както всичко останало в Ruby:
  example:
    primes = [2, 3, 5, 7, 11]

    primes.each { |n| puts n }

    primes.each do |n|
      puts n
    end

= slide '"Къдрави скоби" и do/end', 'преговор от предната сбирка' do
  ul
    li.action По конвенция, фигурни скоби се ползват, когато целият блок е на един ред
    li.action <code>do</code>/<code>end</code> се ползва, когато блокът е няколко реда
    li.action Това е конвенцията, която ще спазваме и ние

= slide "next и break" do
  p
    ' <code>next</code> прескача изпълнението до края на блока и продължава
      със следващия елемент, ала <code>continue</code> в <code>C/Java</code>.
  p <code>break</code> прекъсва итерацията и продължава изпълнението след блока.

  .action
    example:
      numbers.sort.each do |number|
        next if number.odd?
        break if number > 100

        puts number
      end

= slide 'Хешове' do
  list:
    Важна част в програмирането на Ruby
    Майсторското овладяване е задължително!
    Още: хеш таблици, асоциативен списък, речник, map

= slide 'Хешове', 'общи факти' do
  list:
    Класът е `Hash`, но има и литерален синтаксис – `{}`
    Дефинират се така: `{1 => :one, 2 => :two}`
    Ключовете трябва да могат да се хешират: числа, низове, символи, списъци
    По възможност, ключовете трябва да са immutable
    От Ruby 1.9 насам редът на ключовете се запазва

= slide 'Хешове', 'индексиране' do
  annotate:
    numbers = {:one => :eins, :two => :zwei}

    numbers[:one]     # =>
    numbers[:three]   # =>

    numbers[:three] = :drei

    numbers[:three]                     # =>
    numbers.fetch(:four, :keine_ahnung) # =>
    numbers.fetch(:four)                #!

= slide 'Хешове', 'итерация' do
  annotate:
    numbers = {:one => :eins, :two => :zwei}
    numbers.keys    # =>
    numbers.values  # =>

    numbers.each { |pair| puts pair }
    numbers.each { |key, value| puts key, value }

= slide 'Хешове', 'разни методи' do
  annotate:
    numbers = {1 => 2, 3 => 4}

    numbers.has_key?(:three) # =>
    numbers.size             # =>
    numbers.invert           # =>
    numbers.merge({5 => 6})  # =>
    numbers.to_a             # =>
    Hash[1, 2, 3, 4]         # =>

= slide 'Хешове алтернативен синтаксис' do
  p Долните два реда произвеждат еднакви хешове. Второто е 1.9+ синтаксис и ще предпочитаме него по конвенция (когато може):

  example:
    {:one => 1, :two => 2}
    {one: 1, two: 2}

  p Има интересна врътка при извикването на методи, за която ще споменем малко по-натам.

= slide 'Списъци и хешове', 'накратко' do
  list:
    И като цяло всичко, що може да се обхожда (т.е. е [`Enumerable`](http://ruby-doc.org/core-2.1.0/Enumerable.html))
    Ползват се <strong>постоянно</strong>
    Трябва да ги владеете много добре
    Това е едва върхът на айсберга

= slide 'Методи', 'дефиниране' do
  p
    | Дефинирането става с ключовата дума <code>def</code>. Резултатът от функцията е
      последният оценен израз, ако няма <code>return</code> някъде по-рано.

  example:
    def factorial(n)
      if n == 1
        1
      else
        factorial(n - 1) * n
      end
    end

  p В Ruby няма tail recursion оптимизация. Този код яде стек.

= slide 'Методи', 'отгоре-отгоре' do
  list:
    В Ruby няма такова нещо като "глобална функция"
    `def` винаги дефинира метод в някакъв клас
    Ако `def` не е в дефиниция на клас, отива като `private` метод на `Object`
    `puts` е пример за нещо такова, както и методите, които дефинирате в irb
    Дефинирането на методи в `Object` е удачно само за кратки скриптове
    Отвъд тях, дефинирането на методи в `Object` е <strong>ужасно</strong> лош стил

= slide 'Методи в съществуващи класове', 'Ще ви трябва за домашното' do
  p За да добавите метод в съществуващ клас, например <code>Array</code>, просто "отваряте" класа и дефинирате метода:

  annotate:
    class Array
      def fourty_second
        self[41]
      end
    end

    list     = []
    list[41] = 'The Universe'

    list.fourty_second # =>

= slide 'Методи', 'return' do
  p Можете да излезете от функция с <code>return</code>:

  example:
    def includes?(array, element)
      array.each do |item|
        return true if item == element
      end
      false
    end

  p.action
    ' Разбира се, такава функция е излишна.
      Може да ползвате <code>array.include?(element)</code>.

= slide 'Методи', 'стойности по подразбиране' do
  p Параметрите в Ruby могат да имат стойности по подразбиране:

  annotate:
    def order(drink, size = 'large')
      "A #{size} #{drink}, please!"
    end

    order 'tea'             # =>
    order 'coffee', 'small' # =>

= slide 'Методи', 'стойности по подразбиране (2)' do
  list:
    Стойностите по подразбиране могат да бъдат всякакъв израз
    "Всякакъв израз" включва и извикване на друга функция
    Оценяват се на всяко извикване
    Сложни изрази за аргументи по подразбиране са лош стил

= slide 'Методи', 'променлив брой аргументи' do
  p
    | Методите в ruby могат да вземат променлив брой аргументи. Параметърът се означава със
      <code>*</code> и при извикване на функцията съдържа списък от аргументите.

  annotate:
    def say_hi(name, *drinks)
      "Hi, I am #{name} and I enjoy: #{drinks.join(', ')}"
    end

    say_hi 'Mityo', 'coffee', 'tea', 'water' # =>

= slide 'Методи', 'променлив брой аргументи' do
  p Параметърът за променлив брой аргументи може да е на всяка позиция в дефиницията:

  example:
    def something(*a, b, c)
    end

    def something(a, *b, c)
    end

  p Очевидно, може да има само един такъв параметър във функция.

= slide 'Методи', '...и техните приятели, хешовете' do
  p
    ' Когато последният аргумент е хеш, може да изтървете фигурните скобо около него.
      Долните редове правят едно и също:

  example:
    def order(drink, preferences)
    end

    order 'Latte', {:size => 'grande', :syrup => 'hazelnut'}
    order 'Latte', :size => 'grande', :syrup => 'hazelnut'
    order 'Latte', size: 'grande', syrup: 'hazelnut'

  p Така Ruby симулира извикане на функция с наименовани аргументи. Последният ред работи при версия 1.9+

= slide 'Методи', '...и хешове, отново' do
  p Често ще видите код в този вид:

  example:
    def order(drink, preferences = {})
    end

    order 'Latte'
    order 'Latte', size: 'grande', syrup: 'hazelnut'

  p
    ' Така <code>preferences</code> е незадължителен и няма нужда да го подавате, ако
      нямате предпочитания.

= slide 'Псевдо-keyword arguments', 'недостатъци' do
  p Този "трик" с хешовете се ползва много, понякога прекалено много. Той има и ред недостатъци:

  list:
    За да ползвате стойност, трябва да я достъпите през променлива (например `preferences[:size]`)
    Задаването на стойности по подразбиране е криво и може да се прави само в тялото на метода
    Например така: `preferences[:size] ||= 'grande'`
    Или така: `preferences = {size: 'grande', syrup: 'hazelnut'}.merge(preferences)`
    Проверката за задължителни keyword args става пак ръчно
    Проверката дали някой не ви е подал "излишни" и непознати ключови думи за аргументи – пак ръчно

= slide 'Истински keyword arguments' do
  p Горните недостатъци и нуждата водят до появата на истински keyword arguments в Ruby 2.0.

  annotate:
    def order(drink, size: 'grande', syrup: nil)
      message = "You ordered a #{size} #{drink}"
      message << " with a #{syrup} syrup" if syrup
      message
    end

    order 'Latte'                       # =>
    order 'Latte', syrup: 'hazelnut'    # =>
    order 'Latte', filling: 'chocolate' #!

= slide 'Задължителни keyword arguments' do
  example:
    def order(drink:, size: 'grande', syrup: nil)
      message = "You ordered a #{size} #{drink}"
      message << " with a #{syrup} syrup" if syrup
      message
    end

    order drink: 'Latte'                    # "You ordered a grande Latte"
    order syrup: 'hazelnut', drink: 'Latte' # "You ordered a grande Latte with a hazelnut syrup"
    order                                   # error: ArgumentError: missing keyword: drink

= slide 'Истински keyword arguments', 'предимства' do
  list:
    Ако има стойност по подрзбиране, тя се задава редом с дефиницията на метода
    Позвате стойността на аргумента директно, няма нужда от отделна променлива
    Непознати ключови думи, подадени като аргументи, предизвикват грешка
    Липсващи и задължителни ключови думи за аргументи също предизвикват грешка

= slide 'Методи', 'предикати' do
  p
    ' Името на метод може да завършва на <code>?</code>. Това се ползва, за методи,
      които връщат лъжа или истина (предикати):

  example:
    def even?(n)
      n % 2 == 0
    end

    even? 2
    even? 3

  p Това е само конвенция.

= slide 'Методи', 'две версии' do
  p
    ' Името на метод може да завършва на <code>!</code>.
      Това се ползва, когато <strong>методът има две версии с различно поведение</strong>:

  example:
    numbers = [4, 1, 3, 2, 5, 0]

    numbers.sort   # връща нов списък
    numbers.sort!  # променя списъка на място

  p В случая, "по-опасният" метод завършва на удивителна.
  p Ако имате само една версия на метод с такова име, не слагайте удивителна.

= slide 'Анонимни функции', 'ламбди' do
  p
    ' Анонимни функции в Ruby се дефинират с <code>lambda</code>. Имат три начина на извикване:

  example:
    pow = lambda { |a, b| a ** b }

    pow.call 2, 3
    pow[2, 3]
    pow.(2, 3)

  p
    ' За нещастие, не може да извиквате така: <code>double(2)</code>. Това е несъвместимо с
      изтърваването на скобите при извикването на метод.

= slide 'Анонимни функции', 'ламбди (2)' do
  p Може и така:

  example:
    double = lambda do |x|
      x * 2
    end

  p Важи стандартната конвенция за <code>{ }</code> и <code>do</code>/<code>end</code>.

= slide 'Анонимни функции', 'ламбди (3)' do
  p От 1.9 има по-симпатичен синтаксис за ламбди:

  example:
    say_hi = lambda { puts 'Hi there!' }
    double = lambda { |x| x * 2 }
    divide = lambda { |a, b| a / b }

    say_hi = -> { puts 'Hi there' }
    double = ->(x) { x * 2 }
    divide = ->(a, b) { a / b }

= slide 'Блокове', 'където става забавно' do
  p
    ' Всеки метод в може да приеме допълнителен аргумент, който е "анонимна функция". Може да
      го извикате от метода с <code>yield</code>:

  example:
    def twice
      yield
      yield
    end

    twice { puts 'Ruby rocks!' }

= slide 'Блокове', 'аргументи' do
  p Блокът може да приема аргументи:

  example:
    def sequence(first, last, step)
      current = first
      while current < last
        yield current
        current += step
      end
    end

    sequence(1, 10, 2) { |n| puts n }
    # Извежда 1, 3, 5, 7, 9

= slide 'Блокове', 'стойности' do
  p <code>yield</code> се оценява до стойността на блока:

  annotate:
    def calculate
      result = yield(2)
      "The result for 2 is #{result}"
    end

    calculate { |x| x ** 2 } # =>

= slide 'Блокове', 'един пример' do
  p Или как можем да напишем <code>filter</code>:

  annotate:
    def filter(array)
      result = []
      array.each do |item|
        result << item if yield item
      end
      result
    end

    filter([1, 2, 3, 4, 5]) { |n| n.odd? } # =>

  .action
    p Разбира се, такъв метод в Ruby вече съществува – <code>Enumerable#reject</code>.

= slide 'Блокове', '#block_given?' do
  p <code>block_given?</code> ще ви каже дали методът е извикан с блок:

  example:
    def i_can_haz_block
      if block_given?
        puts 'yes'
      else
        puts 'no'
      end
    end

    i_can_haz_block                  # no
    i_can_haz_block { 'something' }  # yes

= slide 'Блокове', '& при извикване на метод' do
  p Ако имате ламбда, която искате да подадете като блок, може да ползвате <code>&</code>:

  example:
    is_odd = lambda { |n| n.odd? }

    filter([1, 2, 3, 4, 5], &is_odd)
    filter([1, 2, 3, 4, 5]) { |n| n.odd? }

  p Горните са (почти) еквиваленти. Има малка разлика в някои други случаи.

= slide 'Блокове', 'в сигнатурата' do
  p Ако искате да вземете блока като обект, има начин:

  example:
    def invoke_with(*args, &block)
      block.(*args)
    end

    invoke_with(1, 2) { |a, b| puts a + b }

= slide 'Блокове', 'в сигнатурата (2)' do
  p Може и така:

  annotate:
    def make_block(&block)
      block
    end

    doubler = make_block { |n| n * 2 }
    doubler.(2) # =>

= slide 'Сряда', 'където пием бира' do
  list:
    Следващото събиране няма да е във ФМИ, а на "по бира"
    Сряда, 16 октомври, в [Maze](https://www.facebook.com/mazesofia)
    Кажете, че ще идвате в [събитието във Фейсбук](https://www.facebook.com/events/537931419620371/)
    Успех със задачата и предизвикателството и до сряда!
